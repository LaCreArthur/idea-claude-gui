plugins {
    id 'java'
    id 'checkstyle'
    id 'org.jetbrains.intellij.platform' version '2.10.5'
}

checkstyle {
    toolVersion = '10.12.5'
    configFile = file('checkstyle.xml')
}

group = 'com.lacrearthur.idea-claude-gui'
version = '0.2.1'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
    intellijPlatform {
        defaultRepositories()
    }
}

dependencies {
    implementation 'com.google.code.gson:gson:2.10.1'

    // Testing - JUnit 5 with JUnit 4 compatibility for IntelliJ Platform (IJPL-159134)
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testImplementation 'org.junit.vintage:junit-vintage-engine:5.10.1'
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.opentest4j:opentest4j:1.3.0'  // IJPL-157292 workaround
    testImplementation 'org.mockito:mockito-core:5.8.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.8.0'

    intellijPlatform {
        intellijIdeaCommunity('2024.3.1')
        instrumentationTools()
    }
}

tasks.test {
    useJUnitPlatform()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

// Ensure plugin.xml is patched with the correct since/until build and change notes
patchPluginXml {
    // plugin compatibility range
    sinceBuild = '233'
    untilBuild = '263.*'

    // Release notes shown in plugin repositories
    // Dynamically load the latest changelog entry from CHANGELOG.md and convert to simple HTML.
    def changelogFile = file('CHANGELOG.md')
    def computedChangeNotes = ''
    if (changelogFile.exists()) {
        def lines = changelogFile.readLines('UTF-8')
        // Find first section header (lines starting with '#####')
        def start = -1
        for (int i = 0; i < lines.size(); i++) {
            if (lines[i].trim().startsWith('#####')) {
                start = i
                break
            }
        }

        if (start >= 0) {
            def sb = new StringBuilder()
            boolean inList = false
            int i = start + 1
            while (i < lines.size() && !lines[i].trim().startsWith('#####')) {
                def line = lines[i]
                def t = line.trim()

                if (t.startsWith('- ')) {
                    if (!inList) { sb.append('<ul>'); inList = true }
                    def item = t.substring(2)
                    // remove checkbox markers like [x] or [ ]
                    if (item.startsWith('[') && item.length() > 3 && item.charAt(2) == ']') {
                        item = item.substring(3).trim()
                    }
                    item = item.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                    sb.append('<li>' + item + '</li>')
                } else if (t.startsWith('![') || t.startsWith('<img')) {
                    // skip images
                } else if (t.length() == 0) {
                    if (inList) { sb.append('</ul>'); inList = false }
                    sb.append('<br/>')
                } else {
                    if (inList) { sb.append('</ul>'); inList = false }
                    // paragraph
                    def para = t.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                    sb.append('<p>' + para + '</p>')
                }

                i++
            }
            if (inList) { sb.append('</ul>') }
            computedChangeNotes = sb.toString()
        }
    }

    changeNotes = computedChangeNotes ?: '<p>No changelog found.</p>'
}

// Disable product-specific searchable options/instrument tasks if present
// Use matching to cover task name variants like buildSearchableOptionsIC / buildSearchableOptionsIU etc.
tasks.matching { it.name.startsWith('buildSearchableOptions') }.configureEach {
    enabled = false
}

tasks.named('buildSearchableOptions') {
    enabled = false
}

tasks.named('instrumentCode') {
    enabled = false
}

tasks.named('jarSearchableOptions') {
    enabled = false
}

tasks.named('runIde') {
    jvmArgumentProviders.add({
        [
            '-Djcef.sandbox.enable=false',
            // Disable plugin auto-unload (prevent unloading when file changes detected)
            '-Didea.auto.reload.plugins=false',
            // Disable dynamic plugin unloading
            '-Didea.dynamic.plugins.allowed=false',
            // Enable internal mode
            '-Didea.is.internal=true',
            // Disable file system event monitoring (optional)
            // '-Didea.filewatcher.disabled=true',
            // Increase plugin loading timeout
            '-Didea.plugins.load.timeout=60000'
        ]
    } as CommandLineArgumentProvider)

    // Set system properties
    systemProperty 'idea.auto.reload.plugins', 'false'
    systemProperty 'idea.dynamic.plugins.allowed', 'false'
    systemProperty 'idea.is.internal', 'true'
    systemProperty 'idea.plugin.in.sandbox.mode', 'true'

    // Configure log output to console
    systemProperty 'idea.log.debug.categories', '#com.github.claudecodegui'

    // Redirect standard output
    standardOutput = System.out
    errorOutput = System.err

    // Copy custom config to sandbox
    doFirst {
        def sandboxConfig = file('sandbox-idea.properties')
        if (sandboxConfig.exists()) {
            def sandboxDir = layout.buildDirectory.dir("idea-sandbox").get().asFile
            def configDir = new File(sandboxDir, 'config')
            configDir.mkdirs()

            copy {
                from sandboxConfig
                into configDir
                rename { 'idea.properties' }
            }
            println "Copied sandbox config to: ${configDir}/idea.properties"
        }
    }
}

// Unified AI Bridge (merged Claude and Codex)
def aiBridgeDir = file("ai-bridge")
def aiBridgePackDir = layout.buildDirectory.dir('ai-bridge-pack').get().asFile
def aiBridgeArchive = new File(aiBridgePackDir, 'ai-bridge.zip')

// Auto-build webview
def webviewDir = file('webview')
def requestedTasks = gradle.startParameter.taskNames.collect { it.toLowerCase() }
def enableVConsoleInWebview = requestedTasks.any { it.contains('runide') }
tasks.register('buildWebview', Exec) {
    workingDir webviewDir
    environment 'VITE_ENABLE_VCONSOLE', enableVConsoleInWebview ? 'true' : 'false'

    if (System.getProperty('os.name').toLowerCase().contains('windows')) {
        commandLine 'cmd', '/c', 'npm', 'run', 'build'
    } else {
        commandLine 'npm', 'run', 'build'
    }

    onlyIf { webviewDir.exists() }
    doFirst { println "Building webview..." }
    doLast { println "Webview build completed." }
}

// Ensure processResources runs after buildWebview
// Use mustRunAfter to ensure execution order, trigger buildWebview before compileJava
tasks.named('compileJava') {
    dependsOn('buildWebview')
}

tasks.named('processResources') {
    mustRunAfter('buildWebview')
}

tasks.register('packageAiBridge', Zip) {
    onlyIf { aiBridgeDir.exists() }
    archiveFileName = 'ai-bridge.zip'
    destinationDirectory = aiBridgePackDir
    from(aiBridgeDir)
    exclude('node_modules/.pnpm/**')
    // Exclude codex-sdk multi-platform binaries (~310MB), runtime will auto-download platform-specific versions
    exclude('node_modules/@openai/codex-sdk/vendor/**')
    includeEmptyDirs = true
}

// Extract plugin name
def pluginName = project.name

tasks.matching { it.name.startsWith('prepareSandbox') }.configureEach {
    dependsOn('buildWebview', 'packageAiBridge')
    def sandboxRootProvider = layout.buildDirectory.dir('idea-sandbox')

    doLast {
        if (!aiBridgeDir.exists() && !aiBridgeArchive.exists()) {
            throw new GradleException('ai-bridge directory not found. Please ensure it has been pulled and dependencies installed.')
        }
        def sandboxRoot = sandboxRootProvider.get().asFile
        def pluginDir = new File(sandboxRoot, "plugins/${pluginName}")

        def extractedDir = new File(pluginDir, 'ai-bridge')
        def archiveTarget = new File(pluginDir, 'ai-bridge.zip')
        project.delete(extractedDir)
        project.delete(archiveTarget)
        project.copy {
            from(aiBridgeArchive)
            into(pluginDir)
        }
    }
}

// Configure tasks after prepareSandbox to ensure ai-bridge.zip is included
tasks.matching { it.name == 'preparePluginForDistribution' || it.name == 'composedJar' }.configureEach {
    dependsOn('packageAiBridge')
}

tasks.named('buildPlugin') {
    dependsOn('packageAiBridge', 'checkstyleMain')

    doLast {
        // Extract plugin zip, add ai-bridge.zip, then repack
        def distributionFile = archiveFile.get().asFile
        if (distributionFile.exists() && aiBridgeArchive.exists()) {
            def tempDir = file("${layout.buildDirectory.get()}/tmp/plugin-repack")
            delete(tempDir)

            // Extract
            copy {
                from zipTree(distributionFile)
                into tempDir
            }

            // Find plugin directory and add ai-bridge.zip
            def pluginDir = new File(tempDir, pluginName)
            if (pluginDir.exists()) {
                copy {
                    from aiBridgeArchive
                    into pluginDir
                }

                // Delete searchableOptions jar (if exists)
                fileTree(new File(pluginDir, 'lib')).matching {
                    include '**/*searchableOptions*.jar'
                }.each { jarFile ->
                    delete(jarFile)
                    println "Deleted searchableOptions jar: ${jarFile.name}"
                }

                // Repack
                delete(distributionFile)
                ant.zip(destfile: distributionFile) {
                    fileset(dir: tempDir)
                }
                println "Added ai-bridge.zip to plugin package and removed searchableOptions jar"
            }

            delete(tempDir)
        }
    }
}
